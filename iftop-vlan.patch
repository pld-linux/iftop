diff -dur iftop-0.16.orig/ether.h iftop-0.16/ether.h
--- iftop-0.16.orig/ether.h	Fri Oct 18 19:29:32 2002
+++ iftop-0.16/ether.h	Thu Mar 31 13:41:28 2005
@@ -14,4 +14,9 @@
 	u_int16_t	ether_type;
 };
 
+struct vlan_8021q_header {
+	u_int16_t	priority_cfi_vid;
+	u_int16_t	ether_type;
+};
+
 #endif 
diff -dur iftop-0.16.orig/iftop.c iftop-0.16/iftop.c
--- iftop-0.16.orig/iftop.c	Thu Mar 31 13:17:07 2005
+++ iftop-0.16/iftop.c	Thu Mar 31 13:42:41 2005
@@ -81,8 +81,8 @@
 
 
 
-/* Only need ethernet and IP headers (48) + first 2 bytes of tcp/udp header */
-#define CAPTURE_LENGTH 68
+/* Only need ethernet (plus optional 4 byte VLAN) and IP headers (48) + first 2 bytes of tcp/udp header */
+#define CAPTURE_LENGTH 72
 
 void init_history() {
     history = addr_hash_create();
@@ -384,11 +384,22 @@
 static void handle_eth_packet(unsigned char* args, const struct pcap_pkthdr* pkthdr, const unsigned char* packet)
 {
     struct ether_header *eptr;
+    int ether_type;
+    const unsigned char *payload;
     eptr = (struct ether_header*)packet;
+    ether_type = ntohs(eptr->ether_type);
+    payload = packet + sizeof(struct ether_header);
 
     tick(0);
 
-    if(ntohs(eptr->ether_type) == ETHERTYPE_IP) {
+    if(ether_type == ETHERTYPE_8021Q) {
+	struct vlan_8021q_header* vptr;
+	vptr = (struct vlan_8021q_header*)payload;
+	ether_type = ntohs(vptr->ether_type);
+        payload += sizeof(struct vlan_8021q_header);
+    }
+
+    if(ether_type == ETHERTYPE_IP) {
         struct ip* iptr;
         int dir = -1;
         
@@ -408,7 +419,7 @@
             dir = 0;
         }
 
-        iptr = (struct ip*)(packet + sizeof(struct ether_header) ); /* alignment? */
+        iptr = (struct ip*)(payload); /* alignment? */
         handle_ip_packet(iptr, dir);
     }
 }
@@ -420,10 +431,10 @@
 char *set_filter_code(const char *filter) {
     char *x;
     if (filter) {
-        x = xmalloc(strlen(filter) + sizeof "() and ip");
-        sprintf(x, "(%s) and ip", filter);
+        x = xmalloc(strlen(filter) + sizeof "() and (ip or vlan and ip)");
+        sprintf(x, "(%s) and (ip or vlan and ip)", filter);
     } else
-        x = xstrdup("ip");
+        x = xstrdup("ip or vlan and ip");
     if (pcap_compile(pd, &pcap_filter, x, 1, 0) == -1) {
         xfree(x);
         return pcap_geterr(pd);
